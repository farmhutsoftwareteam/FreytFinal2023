/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/command-score";
exports.ids = ["vendor-chunks/command-score"];
exports.modules = {

/***/ "(ssr)/./node_modules/command-score/index.js":
/*!*********************************************!*\
  !*** ./node_modules/command-score/index.js ***!
  \*********************************************/
/***/ ((module) => {

eval("// The scores are arranged so that a continuous match of characters will\n// result in a total score of 1.\n//\n// The best case, this character is a match, and either this is the start\n// of the string, or the previous character was also a match.\nvar SCORE_CONTINUE_MATCH = 1,\n\n    // A new match at the start of a word scores better than a new match\n    // elsewhere as it's more likely that the user will type the starts\n    // of fragments.\n    // (Our notion of word includes CamelCase and hypen-separated, etc.)\n    SCORE_WORD_JUMP = 0.9,\n\n    // Any other match isn't ideal, but we include it for completeness.\n    SCORE_CHARACTER_JUMP = 0.3,\n\n    // If the user transposed two letters, it should be signficantly penalized.\n    //\n    // i.e. \"ouch\" is more likely than \"curtain\" when \"uc\" is typed.\n    SCORE_TRANSPOSITION = 0.1,\n\n    // If the user jumped to half-way through a subsequent word, it should be\n    // very significantly penalized.\n    //\n    // i.e. \"loes\" is very unlikely to match \"loch ness\".\n    // NOTE: this is set to 0 for superhuman right now, but we may want to revisit.\n    SCORE_LONG_JUMP = 0,\n\n    // The goodness of a match should decay slightly with each missing\n    // character.\n    //\n    // i.e. \"bad\" is more likely than \"bard\" when \"bd\" is typed.\n    //\n    // This will not change the order of suggestions based on SCORE_* until\n    // 100 characters are inserted between matches.\n    PENALTY_SKIPPED = 0.999,\n\n    // The goodness of an exact-case match should be higher than a\n    // case-insensitive match by a small amount.\n    //\n    // i.e. \"HTML\" is more likely than \"haml\" when \"HM\" is typed.\n    //\n    // This will not change the order of suggestions based on SCORE_* until\n    // 1000 characters are inserted between matches.\n    PENALTY_CASE_MISMATCH = 0.9999,\n\n    // If the word has more characters than the user typed, it should\n    // be penalised slightly.\n    //\n    // i.e. \"html\" is more likely than \"html5\" if I type \"html\".\n    //\n    // However, it may well be the case that there's a sensible secondary\n    // ordering (like alphabetical) that it makes sense to rely on when\n    // there are many prefix matches, so we don't make the penalty increase\n    // with the number of tokens.\n    PENALTY_NOT_COMPLETE = 0.99;\n\nvar IS_GAP_REGEXP = /[\\\\\\/\\-_+.# \\t\"@\\[\\(\\{&]/,\n    COUNT_GAPS_REGEXP = /[\\\\\\/\\-_+.# \\t\"@\\[\\(\\{&]/g;\n\nfunction commandScoreInner(string, abbreviation, lowerString, lowerAbbreviation, stringIndex, abbreviationIndex) {\n\n    if (abbreviationIndex === abbreviation.length) {\n        if (stringIndex === string.length) {\n            return SCORE_CONTINUE_MATCH;\n\n        }\n        return PENALTY_NOT_COMPLETE;\n    }\n\n    var abbreviationChar = lowerAbbreviation.charAt(abbreviationIndex);\n    var index = lowerString.indexOf(abbreviationChar, stringIndex);\n    var highScore = 0;\n\n    var score, transposedScore, wordBreaks;\n\n    while (index >= 0) {\n\n        score = commandScoreInner(string, abbreviation, lowerString, lowerAbbreviation, index + 1, abbreviationIndex + 1);\n        if (score > highScore) {\n            if (index === stringIndex) {\n                score *= SCORE_CONTINUE_MATCH;\n            } else if (IS_GAP_REGEXP.test(string.charAt(index - 1))) {\n                score *= SCORE_WORD_JUMP;\n                wordBreaks = string.slice(stringIndex, index - 1).match(COUNT_GAPS_REGEXP);\n                if (wordBreaks && stringIndex > 0) {\n                    score *= Math.pow(PENALTY_SKIPPED, wordBreaks.length);\n                }\n            } else if (IS_GAP_REGEXP.test(string.slice(stringIndex, index - 1))) {\n                score *= SCORE_LONG_JUMP;\n                if (stringIndex > 0) {\n                    score *= Math.pow(PENALTY_SKIPPED, index - stringIndex);\n                }\n            } else {\n                score *= SCORE_CHARACTER_JUMP;\n                if (stringIndex > 0) {\n                    score *= Math.pow(PENALTY_SKIPPED, index - stringIndex);\n                }\n            }\n\n            if (string.charAt(index) !== abbreviation.charAt(abbreviationIndex)) {\n                score *= PENALTY_CASE_MISMATCH;\n            }\n\n        }\n\n        if (score < SCORE_TRANSPOSITION &&\n                lowerString.charAt(index - 1) === lowerAbbreviation.charAt(abbreviationIndex + 1) &&\n                lowerString.charAt(index - 1) !== lowerAbbreviation.charAt(abbreviationIndex)) {\n            transposedScore = commandScoreInner(string, abbreviation, lowerString, lowerAbbreviation, index + 1, abbreviationIndex + 2);\n\n            if (transposedScore * SCORE_TRANSPOSITION > score) {\n                score = transposedScore * SCORE_TRANSPOSITION;\n            }\n        }\n\n        if (score > highScore) {\n            highScore = score;\n        }\n\n        index = lowerString.indexOf(abbreviationChar, index + 1);\n    }\n\n    return highScore;\n}\n\nfunction commandScore(string, abbreviation) {\n    /* NOTE:\n     * in the original, we used to do the lower-casing on each recursive call, but this meant that toLowerCase()\n     * was the dominating cost in the algorithm, passing both is a little ugly, but considerably faster.\n     */\n    return commandScoreInner(string, abbreviation, string.toLowerCase(), abbreviation.toLowerCase(), 0, 0);\n}\n\nmodule.exports = commandScore;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY29tbWFuZC1zY29yZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDLCtDQUErQzs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9jb21tYW5kLXNjb3JlL2luZGV4LmpzP2I0NmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhlIHNjb3JlcyBhcmUgYXJyYW5nZWQgc28gdGhhdCBhIGNvbnRpbnVvdXMgbWF0Y2ggb2YgY2hhcmFjdGVycyB3aWxsXG4vLyByZXN1bHQgaW4gYSB0b3RhbCBzY29yZSBvZiAxLlxuLy9cbi8vIFRoZSBiZXN0IGNhc2UsIHRoaXMgY2hhcmFjdGVyIGlzIGEgbWF0Y2gsIGFuZCBlaXRoZXIgdGhpcyBpcyB0aGUgc3RhcnRcbi8vIG9mIHRoZSBzdHJpbmcsIG9yIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIgd2FzIGFsc28gYSBtYXRjaC5cbnZhciBTQ09SRV9DT05USU5VRV9NQVRDSCA9IDEsXG5cbiAgICAvLyBBIG5ldyBtYXRjaCBhdCB0aGUgc3RhcnQgb2YgYSB3b3JkIHNjb3JlcyBiZXR0ZXIgdGhhbiBhIG5ldyBtYXRjaFxuICAgIC8vIGVsc2V3aGVyZSBhcyBpdCdzIG1vcmUgbGlrZWx5IHRoYXQgdGhlIHVzZXIgd2lsbCB0eXBlIHRoZSBzdGFydHNcbiAgICAvLyBvZiBmcmFnbWVudHMuXG4gICAgLy8gKE91ciBub3Rpb24gb2Ygd29yZCBpbmNsdWRlcyBDYW1lbENhc2UgYW5kIGh5cGVuLXNlcGFyYXRlZCwgZXRjLilcbiAgICBTQ09SRV9XT1JEX0pVTVAgPSAwLjksXG5cbiAgICAvLyBBbnkgb3RoZXIgbWF0Y2ggaXNuJ3QgaWRlYWwsIGJ1dCB3ZSBpbmNsdWRlIGl0IGZvciBjb21wbGV0ZW5lc3MuXG4gICAgU0NPUkVfQ0hBUkFDVEVSX0pVTVAgPSAwLjMsXG5cbiAgICAvLyBJZiB0aGUgdXNlciB0cmFuc3Bvc2VkIHR3byBsZXR0ZXJzLCBpdCBzaG91bGQgYmUgc2lnbmZpY2FudGx5IHBlbmFsaXplZC5cbiAgICAvL1xuICAgIC8vIGkuZS4gXCJvdWNoXCIgaXMgbW9yZSBsaWtlbHkgdGhhbiBcImN1cnRhaW5cIiB3aGVuIFwidWNcIiBpcyB0eXBlZC5cbiAgICBTQ09SRV9UUkFOU1BPU0lUSU9OID0gMC4xLFxuXG4gICAgLy8gSWYgdGhlIHVzZXIganVtcGVkIHRvIGhhbGYtd2F5IHRocm91Z2ggYSBzdWJzZXF1ZW50IHdvcmQsIGl0IHNob3VsZCBiZVxuICAgIC8vIHZlcnkgc2lnbmlmaWNhbnRseSBwZW5hbGl6ZWQuXG4gICAgLy9cbiAgICAvLyBpLmUuIFwibG9lc1wiIGlzIHZlcnkgdW5saWtlbHkgdG8gbWF0Y2ggXCJsb2NoIG5lc3NcIi5cbiAgICAvLyBOT1RFOiB0aGlzIGlzIHNldCB0byAwIGZvciBzdXBlcmh1bWFuIHJpZ2h0IG5vdywgYnV0IHdlIG1heSB3YW50IHRvIHJldmlzaXQuXG4gICAgU0NPUkVfTE9OR19KVU1QID0gMCxcblxuICAgIC8vIFRoZSBnb29kbmVzcyBvZiBhIG1hdGNoIHNob3VsZCBkZWNheSBzbGlnaHRseSB3aXRoIGVhY2ggbWlzc2luZ1xuICAgIC8vIGNoYXJhY3Rlci5cbiAgICAvL1xuICAgIC8vIGkuZS4gXCJiYWRcIiBpcyBtb3JlIGxpa2VseSB0aGFuIFwiYmFyZFwiIHdoZW4gXCJiZFwiIGlzIHR5cGVkLlxuICAgIC8vXG4gICAgLy8gVGhpcyB3aWxsIG5vdCBjaGFuZ2UgdGhlIG9yZGVyIG9mIHN1Z2dlc3Rpb25zIGJhc2VkIG9uIFNDT1JFXyogdW50aWxcbiAgICAvLyAxMDAgY2hhcmFjdGVycyBhcmUgaW5zZXJ0ZWQgYmV0d2VlbiBtYXRjaGVzLlxuICAgIFBFTkFMVFlfU0tJUFBFRCA9IDAuOTk5LFxuXG4gICAgLy8gVGhlIGdvb2RuZXNzIG9mIGFuIGV4YWN0LWNhc2UgbWF0Y2ggc2hvdWxkIGJlIGhpZ2hlciB0aGFuIGFcbiAgICAvLyBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGJ5IGEgc21hbGwgYW1vdW50LlxuICAgIC8vXG4gICAgLy8gaS5lLiBcIkhUTUxcIiBpcyBtb3JlIGxpa2VseSB0aGFuIFwiaGFtbFwiIHdoZW4gXCJITVwiIGlzIHR5cGVkLlxuICAgIC8vXG4gICAgLy8gVGhpcyB3aWxsIG5vdCBjaGFuZ2UgdGhlIG9yZGVyIG9mIHN1Z2dlc3Rpb25zIGJhc2VkIG9uIFNDT1JFXyogdW50aWxcbiAgICAvLyAxMDAwIGNoYXJhY3RlcnMgYXJlIGluc2VydGVkIGJldHdlZW4gbWF0Y2hlcy5cbiAgICBQRU5BTFRZX0NBU0VfTUlTTUFUQ0ggPSAwLjk5OTksXG5cbiAgICAvLyBJZiB0aGUgd29yZCBoYXMgbW9yZSBjaGFyYWN0ZXJzIHRoYW4gdGhlIHVzZXIgdHlwZWQsIGl0IHNob3VsZFxuICAgIC8vIGJlIHBlbmFsaXNlZCBzbGlnaHRseS5cbiAgICAvL1xuICAgIC8vIGkuZS4gXCJodG1sXCIgaXMgbW9yZSBsaWtlbHkgdGhhbiBcImh0bWw1XCIgaWYgSSB0eXBlIFwiaHRtbFwiLlxuICAgIC8vXG4gICAgLy8gSG93ZXZlciwgaXQgbWF5IHdlbGwgYmUgdGhlIGNhc2UgdGhhdCB0aGVyZSdzIGEgc2Vuc2libGUgc2Vjb25kYXJ5XG4gICAgLy8gb3JkZXJpbmcgKGxpa2UgYWxwaGFiZXRpY2FsKSB0aGF0IGl0IG1ha2VzIHNlbnNlIHRvIHJlbHkgb24gd2hlblxuICAgIC8vIHRoZXJlIGFyZSBtYW55IHByZWZpeCBtYXRjaGVzLCBzbyB3ZSBkb24ndCBtYWtlIHRoZSBwZW5hbHR5IGluY3JlYXNlXG4gICAgLy8gd2l0aCB0aGUgbnVtYmVyIG9mIHRva2Vucy5cbiAgICBQRU5BTFRZX05PVF9DT01QTEVURSA9IDAuOTk7XG5cbnZhciBJU19HQVBfUkVHRVhQID0gL1tcXFxcXFwvXFwtXysuIyBcXHRcIkBcXFtcXChcXHsmXS8sXG4gICAgQ09VTlRfR0FQU19SRUdFWFAgPSAvW1xcXFxcXC9cXC1fKy4jIFxcdFwiQFxcW1xcKFxceyZdL2c7XG5cbmZ1bmN0aW9uIGNvbW1hbmRTY29yZUlubmVyKHN0cmluZywgYWJicmV2aWF0aW9uLCBsb3dlclN0cmluZywgbG93ZXJBYmJyZXZpYXRpb24sIHN0cmluZ0luZGV4LCBhYmJyZXZpYXRpb25JbmRleCkge1xuXG4gICAgaWYgKGFiYnJldmlhdGlvbkluZGV4ID09PSBhYmJyZXZpYXRpb24ubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzdHJpbmdJbmRleCA9PT0gc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFNDT1JFX0NPTlRJTlVFX01BVENIO1xuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBFTkFMVFlfTk9UX0NPTVBMRVRFO1xuICAgIH1cblxuICAgIHZhciBhYmJyZXZpYXRpb25DaGFyID0gbG93ZXJBYmJyZXZpYXRpb24uY2hhckF0KGFiYnJldmlhdGlvbkluZGV4KTtcbiAgICB2YXIgaW5kZXggPSBsb3dlclN0cmluZy5pbmRleE9mKGFiYnJldmlhdGlvbkNoYXIsIHN0cmluZ0luZGV4KTtcbiAgICB2YXIgaGlnaFNjb3JlID0gMDtcblxuICAgIHZhciBzY29yZSwgdHJhbnNwb3NlZFNjb3JlLCB3b3JkQnJlYWtzO1xuXG4gICAgd2hpbGUgKGluZGV4ID49IDApIHtcblxuICAgICAgICBzY29yZSA9IGNvbW1hbmRTY29yZUlubmVyKHN0cmluZywgYWJicmV2aWF0aW9uLCBsb3dlclN0cmluZywgbG93ZXJBYmJyZXZpYXRpb24sIGluZGV4ICsgMSwgYWJicmV2aWF0aW9uSW5kZXggKyAxKTtcbiAgICAgICAgaWYgKHNjb3JlID4gaGlnaFNjb3JlKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IHN0cmluZ0luZGV4KSB7XG4gICAgICAgICAgICAgICAgc2NvcmUgKj0gU0NPUkVfQ09OVElOVUVfTUFUQ0g7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKElTX0dBUF9SRUdFWFAudGVzdChzdHJpbmcuY2hhckF0KGluZGV4IC0gMSkpKSB7XG4gICAgICAgICAgICAgICAgc2NvcmUgKj0gU0NPUkVfV09SRF9KVU1QO1xuICAgICAgICAgICAgICAgIHdvcmRCcmVha3MgPSBzdHJpbmcuc2xpY2Uoc3RyaW5nSW5kZXgsIGluZGV4IC0gMSkubWF0Y2goQ09VTlRfR0FQU19SRUdFWFApO1xuICAgICAgICAgICAgICAgIGlmICh3b3JkQnJlYWtzICYmIHN0cmluZ0luZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzY29yZSAqPSBNYXRoLnBvdyhQRU5BTFRZX1NLSVBQRUQsIHdvcmRCcmVha3MubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKElTX0dBUF9SRUdFWFAudGVzdChzdHJpbmcuc2xpY2Uoc3RyaW5nSW5kZXgsIGluZGV4IC0gMSkpKSB7XG4gICAgICAgICAgICAgICAgc2NvcmUgKj0gU0NPUkVfTE9OR19KVU1QO1xuICAgICAgICAgICAgICAgIGlmIChzdHJpbmdJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmUgKj0gTWF0aC5wb3coUEVOQUxUWV9TS0lQUEVELCBpbmRleCAtIHN0cmluZ0luZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjb3JlICo9IFNDT1JFX0NIQVJBQ1RFUl9KVU1QO1xuICAgICAgICAgICAgICAgIGlmIChzdHJpbmdJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmUgKj0gTWF0aC5wb3coUEVOQUxUWV9TS0lQUEVELCBpbmRleCAtIHN0cmluZ0luZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdHJpbmcuY2hhckF0KGluZGV4KSAhPT0gYWJicmV2aWF0aW9uLmNoYXJBdChhYmJyZXZpYXRpb25JbmRleCkpIHtcbiAgICAgICAgICAgICAgICBzY29yZSAqPSBQRU5BTFRZX0NBU0VfTUlTTUFUQ0g7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY29yZSA8IFNDT1JFX1RSQU5TUE9TSVRJT04gJiZcbiAgICAgICAgICAgICAgICBsb3dlclN0cmluZy5jaGFyQXQoaW5kZXggLSAxKSA9PT0gbG93ZXJBYmJyZXZpYXRpb24uY2hhckF0KGFiYnJldmlhdGlvbkluZGV4ICsgMSkgJiZcbiAgICAgICAgICAgICAgICBsb3dlclN0cmluZy5jaGFyQXQoaW5kZXggLSAxKSAhPT0gbG93ZXJBYmJyZXZpYXRpb24uY2hhckF0KGFiYnJldmlhdGlvbkluZGV4KSkge1xuICAgICAgICAgICAgdHJhbnNwb3NlZFNjb3JlID0gY29tbWFuZFNjb3JlSW5uZXIoc3RyaW5nLCBhYmJyZXZpYXRpb24sIGxvd2VyU3RyaW5nLCBsb3dlckFiYnJldmlhdGlvbiwgaW5kZXggKyAxLCBhYmJyZXZpYXRpb25JbmRleCArIDIpO1xuXG4gICAgICAgICAgICBpZiAodHJhbnNwb3NlZFNjb3JlICogU0NPUkVfVFJBTlNQT1NJVElPTiA+IHNjb3JlKSB7XG4gICAgICAgICAgICAgICAgc2NvcmUgPSB0cmFuc3Bvc2VkU2NvcmUgKiBTQ09SRV9UUkFOU1BPU0lUSU9OO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjb3JlID4gaGlnaFNjb3JlKSB7XG4gICAgICAgICAgICBoaWdoU2NvcmUgPSBzY29yZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ID0gbG93ZXJTdHJpbmcuaW5kZXhPZihhYmJyZXZpYXRpb25DaGFyLCBpbmRleCArIDEpO1xuICAgIH1cblxuICAgIHJldHVybiBoaWdoU2NvcmU7XG59XG5cbmZ1bmN0aW9uIGNvbW1hbmRTY29yZShzdHJpbmcsIGFiYnJldmlhdGlvbikge1xuICAgIC8qIE5PVEU6XG4gICAgICogaW4gdGhlIG9yaWdpbmFsLCB3ZSB1c2VkIHRvIGRvIHRoZSBsb3dlci1jYXNpbmcgb24gZWFjaCByZWN1cnNpdmUgY2FsbCwgYnV0IHRoaXMgbWVhbnQgdGhhdCB0b0xvd2VyQ2FzZSgpXG4gICAgICogd2FzIHRoZSBkb21pbmF0aW5nIGNvc3QgaW4gdGhlIGFsZ29yaXRobSwgcGFzc2luZyBib3RoIGlzIGEgbGl0dGxlIHVnbHksIGJ1dCBjb25zaWRlcmFibHkgZmFzdGVyLlxuICAgICAqL1xuICAgIHJldHVybiBjb21tYW5kU2NvcmVJbm5lcihzdHJpbmcsIGFiYnJldmlhdGlvbiwgc3RyaW5nLnRvTG93ZXJDYXNlKCksIGFiYnJldmlhdGlvbi50b0xvd2VyQ2FzZSgpLCAwLCAwKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21tYW5kU2NvcmU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/command-score/index.js\n");

/***/ })

};
;